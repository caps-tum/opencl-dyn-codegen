<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AMDAPPProfilerHelp: APP Profiler Summary Pages</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1><a class="anchor" name="CLSummaryPage">APP Profiler Summary Pages </a></h1><div align="center">
<img src="CLSummaryPages.png" alt="CLSummaryPages.png">
</div>
<p>
The APP Profiler Summary Pages shows the statistics for your OpenCL&trade; application. They can provide you with a general idea of the location of the application's bottlenecks. They also provide information such as the number of buffers and number of images created on each context, the most expensive kernel call, etc. One Summary Page, the "Warning(s)/Error(s)" page shows the result of a rule-based analysis of the API trace and timeline data. You can sort each column in a summary page by clicking the table header. You can also rearrange the columns by dragging them to a new location. Summary Pages are automatically generated when performing an API trace inside Visual Studio. To generate summary pages from command line, please refer to <a class="el" href="usingthecommandlinesection.html">How To: Use the Command Line</a>. You can find summary pages under the same directory as .atp file. You can view each summary page in your default web browser as all summary pages are in html format.  
<style type="text/css">
   th {
   font-size:1em;
   text-align:left;
   padding-top:5px;
   padding-bottom:4px;
   background-color:#969696;
   color:#fff;
   }
   td, th {
   font-size:0.75em;
   border:1px solid #969696;
   padding:3px 7px 2px 7px;
   }
   table {
        font-family:"Trebuchet MS", Arial, Helvetica, sans-serif;
        width:100%;
        border-collapse:collapse;
   }
</style>
<h3>API Summary Page</h3>
	The API Summary page shows statistics for all OpenCL API calls made by the application.  This page can help to identify any API hotspots.
<p>
	<table>
	<tr>
		<th>API Name</th>	<th># of Calls</th>	<th>Total Time(ms)</th>	<th>Ave Time(ms)</th>	<th>Max Time(ms)</th>	<th>Min Time(ms)</th>	
	</tr>
		<tr bgcolor = "#FFFFFF"><td>clSetKernelArg</td>	<td>60884</td>	<td>106.42239</td>	<td>0.00175</td>	<td>0.07284</td>	<td>0.00147</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clGetKernelInfo</td>	<td>4332</td>	<td>8.29252</td>	<td>0.00191</td>	<td>0.02347</td>	<td>0.00147</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clEnqueueNDRangeKernel</td>	<td>4332</td>	<td>178.09443</td>	<td>0.04111</td>	<td>0.19556</td>	<td>0.00831</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clReleaseMemObject</td>	<td>4265</td>	<td>537.25810</td>	<td>0.12597</td>	<td>1.07458</td>	<td>0.00147</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clCreateBuffer</td>	<td>4265</td>	<td>13.41322</td>	<td>0.00314</td>	<td>0.05622</td>	<td>0.00195</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clEnqueueReadBuffer</td>	<td>938</td>	<td>2403.70320</td>	<td>2.56258</td>	<td>18.78409</td>	<td>0.60280</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clEnqueueWriteBuffer</td>	<td>231</td>	<td>318.01591</td>	<td>1.37669</td>	<td>10.39231</td>	<td>0.78809</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clEnqueueWriteBufferRect</td>	<td>63</td>	<td>1286.34994</td>	<td>20.41825</td>	<td>63.08036</td>	<td>13.78178</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clEnqueueReadBufferRect</td>	<td>63</td>	<td>4288.33441</td>	<td>68.06880</td>	<td>134.18926</td>	<td>45.09560</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clReleaseKernel</td>	<td>13</td>	<td>0.03764</td>	<td>0.00290</td>	<td>0.00440</td>	<td>0.00244</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clCreateKernel</td>	<td>13</td>	<td>0.06600</td>	<td>0.00508</td>	<td>0.00880</td>	<td>0.00293</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clGetDeviceInfo</td>	<td>11</td>	<td>0.03422</td>	<td>0.00311</td>	<td>0.00391</td>	<td>0.00244</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clGetPlatformInfo</td>	<td>5</td>	<td>0.02396</td>	<td>0.00479</td>	<td>0.00635</td>	<td>0.00293</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clGetContextInfo</td>	<td>4</td>	<td>0.02396</td>	<td>0.00599</td>	<td>0.01613</td>	<td>0.00196</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clReleaseContext</td>	<td>2</td>	<td>0.00831</td>	<td>0.00415</td>	<td>0.00587</td>	<td>0.00244</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clCreateContextFromType</td>	<td>2</td>	<td>0.06844</td>	<td>0.03422</td>	<td>0.04547</td>	<td>0.02298</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clReleaseProgram</td>	<td>1</td>	<td>2.08413</td>	<td>2.08413</td>	<td>2.08413</td>	<td>2.08413</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clReleaseCommandQueue</td>	<td>1</td>	<td>97.29672</td>	<td>97.29672</td>	<td>97.29672</td>	<td>97.29672</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clFinish</td>	<td>1</td>	<td>0.06307</td>	<td>0.06307</td>	<td>0.06307</td>	<td>0.06307</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clCreateProgramWithBinary</td>	<td>1</td>	<td>0.58276</td>	<td>0.58276</td>	<td>0.58276</td>	<td>0.58276</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clCreateCommandQueue</td>	<td>1</td>	<td>227.11189</td>	<td>227.11189</td>	<td>227.11189</td>	<td>227.11189</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>clBuildProgram</td>	<td>1</td>	<td>1492.02943</td>	<td>1492.02943</td>	<td>1492.02943</td>	<td>1492.02943</td>	</tr>
	</table>
</p>


<h3>Context Summary Page</h3>
The Context summary page shows the statistics for all the kernel dispatch and data transfer operations for each context. It also shows the number of buffers and images created for each context.
<p>
	<table>
	<tr>
		<th>Context ID</th>	<th># of Buffers</th>	<th># of Images</th>	<th># of Kernel Dispatch - CPU_Device</th>	<th>Total Kernel Time(ms) - CPU_Device</th>	<th># of Kernel Dispatch - Juniper</th>	<th>Total Kernel Time(ms) - Juniper</th>	<th># of Memory Transfer</th>	<th>Total Memory Time(ms)</th>	<th># of Read</th>	<th>Total Read Time(ms)</th>	<th>Size of Read</th>	<th># of Write</th>	<th>Total Write Time(ms)</th>	<th>Size of Write</th>	<th># of Map</th>	<th>Total Map Time(ms)</th>	<th>Size of Map</th>	<th># of Copy</th>	<th>Total Copy Time(ms)</th>	<th>Size of Copy</th>	
	</tr>
		<tr bgcolor = "#FFFFFF"><td>0</td>	<td>2</td>	<td>0</td>	<td>1</td>	<td>69.07170</td>	<td>1</td>	<td>4.10271</td>	<td>2</td>	<td>1.08503</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>2</td>	<td>1.08503</td>	<td>      512.00 KB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>1</td>	<td>2</td>	<td>0</td>	<td>1</td>	<td>35.53000</td>	<td>NA</td>	<td>NA</td>	<td>1</td>	<td>0.21951</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>1</td>	<td>0.21951</td>	<td>      256.00 KB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>2</td>	<td>2</td>	<td>0</td>	<td>NA</td>	<td>NA</td>	<td>1</td>	<td>3.41856</td>	<td>1</td>	<td>0.68449</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>1</td>	<td>0.68449</td>	<td>      256.00 KB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>3</td>	<td>2</td>	<td>0</td>	<td>1</td>	<td>35.73143</td>	<td>NA</td>	<td>NA</td>	<td>1</td>	<td>0.17307</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>1</td>	<td>0.17307</td>	<td>      256.00 KB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>4</td>	<td>2</td>	<td>0</td>	<td>NA</td>	<td>NA</td>	<td>1</td>	<td>1.38896</td>	<td>1</td>	<td>1.45957</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>1</td>	<td>1.45957</td>	<td>      256.00 KB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
	<tfoot>
		<tr bgcolor = "#FFFFFF"><td>Total</td>	<td>10</td>	<td>0</td>	<td>3</td>	<td>140.33313</td>	<td>3</td>	<td>8.91023</td>	<td>6</td>	<td>3.62166</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>6</td>	<td>3.62166</td>	<td>        1.50 MB</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	<td>0</td>	<td>0</td>	<td>         0 Byte</td>	</tr>
	</tfoot>
	</table>
</p>

<h3>Kernel Summary Page</h3>
The Kernel summary page shows statistics for all the kernels that are created by the application.
<p>
	<table>
	<tr>
		<th>Kernel Name</th>	<th>Device Name</th>	<th># of Calls</th>	<th>Total Time(ms)</th>	<th>Avg Time(ms)</th>	<th>Max Time(ms)</th>	<th>Min Time(ms)</th>	
	</tr>
		<tr bgcolor = "#FFFFFF"><td>multiDeviceKernel</td>	<td>CPU_Device</td>	<td>3</td>	<td>140.33313</td>	<td>46.77771</td>	<td>69.07170</td>	<td>35.53000</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>multiDeviceKernel</td>	<td>Juniper</td>	<td>3</td>	<td>8.91023</td>	<td>2.97008</td>	<td>4.10271</td>	<td>1.38896</td>	</tr>
	</table>
</p>

<h3>Top 10 Data Transfer Summary Page</h3>
The Top 10 Data transfer summary page shows a sorted list of the ten most time-consuming data transfers operations. Clicking on a hyperlink takes you to the corresponding item in the Timeline view. <br>
Since data transfer operations can have a great impact on application performance, ensuring that kernel execution operations and data transfer operations overlap can lead to better overall performance. <br>
<p>
	<table>
	<tr>
		<th>Command Type</th>	<th>Context ID</th>	<th>Command Queue ID</th>	<th>Duration(ms)</th>	<th>Transfer Size</th>	<th>Transfer Rate(MB/s)</th>	<th>Thread ID</th>	<th>Sequence ID</th>	
	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=108>WRITE_BUFFER</a></td>	<td>4</td>	<td>5</td>	<td>1.45957</td>	<td>      256.00 KB</td>	<td>171.284</td>	<td>3496</td>	<td>108</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=16>WRITE_BUFFER</a></td>	<td>0</td>	<td>1</td>	<td>0.94618</td>	<td>      256.00 KB</td>	<td>264.220</td>	<td>3496</td>	<td>16</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=56>WRITE_BUFFER</a></td>	<td>2</td>	<td>3</td>	<td>0.68449</td>	<td>      256.00 KB</td>	<td>365.237</td>	<td>3496</td>	<td>56</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=55>WRITE_BUFFER</a></td>	<td>1</td>	<td>2</td>	<td>0.21951</td>	<td>      256.00 KB</td>	<td>1138.895</td>	<td>3496</td>	<td>55</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=107>WRITE_BUFFER</a></td>	<td>3</td>	<td>4</td>	<td>0.17307</td>	<td>      256.00 KB</td>	<td>1444.527</td>	<td>3496</td>	<td>107</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=15>WRITE_BUFFER</a></td>	<td>0</td>	<td>0</td>	<td>0.13885</td>	<td>      256.00 KB</td>	<td>1800.569</td>	<td>3496</td>	<td>15</td>	</tr>
	</table>
</p>

<h3>Top 10 Kernel Summary Page</h3>
The Top 10 kernel summary page shows a sorted list of the 10 most time-consuming kernel execution operations. Clicking on a hyperlink takes you to the corresponding item in Timeline view.
<p>
	<table>
	<tr>
		<th>Kernel Name</th>	<th>Context ID</th>	<th>Command Queue ID</th>	<th>Device Name</th>	<th>Duration(ms)</th>	<th>Global Work Size</th>	<th>Work Group Size</th>	<th>Thread ID</th>	<th>Sequence ID</th>	
	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=21>multiDeviceKernel</a></td>	<td>0</td>	<td>0</td>	<td>CPU_Device</td>	<td>69.07170</td>	<td>{65536}</td>	<td>{64}</td>	<td>3496</td>	<td>21</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=1968&seqid=0>multiDeviceKernel</a></td>	<td>3</td>	<td>4</td>	<td>CPU_Device</td>	<td>35.73143</td>	<td>{65536}</td>	<td>{64}</td>	<td>1968</td>	<td>0</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=61>multiDeviceKernel</a></td>	<td>1</td>	<td>2</td>	<td>CPU_Device</td>	<td>35.53000</td>	<td>{65536}</td>	<td>{64}</td>	<td>3496</td>	<td>61</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=23>multiDeviceKernel</a></td>	<td>0</td>	<td>1</td>	<td>Juniper</td>	<td>4.10271</td>	<td>{65536}</td>	<td>{64}</td>	<td>3496</td>	<td>23</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=3496&seqid=63>multiDeviceKernel</a></td>	<td>2</td>	<td>3</td>	<td>Juniper</td>	<td>3.41856</td>	<td>{65536}</td>	<td>{64}</td>	<td>3496</td>	<td>63</td>	</tr>
		<tr bgcolor = "#FFFFFF"><td><a href=#?tid=2892&seqid=0>multiDeviceKernel</a></td>	<td>4</td>	<td>5</td>	<td>Juniper</td>	<td>1.38896</td>	<td>{65536}</td>	<td>{64}</td>	<td>2892</td>	<td>0</td>	</tr>
	</table>
</p>
<p>
<h3>Warning(s)/Error(s) Page</h3>
The Warning(s)/Error(s) Page shows potential problems in your OpenCL application. It can detect unreleased OpenCL resources, OpenCL API failures and provide suggestions to achieve better performance. Clicking on a hyperlink takes you to the corresponding OpenCL API that generates the message. 
<p>
	<table>
	<tr>
		<th>Index</th>	<th>Call Index</th>	<th>Thread ID</th>	<th>Type</th>	<th>Message</th>		
	</tr>
		<tr bgcolor = "#FFFFFF"><td>0</td>	<td>542</td>	<td>2268</td>	<td>Warning</td>	<td><a href=#?tid=2268&seqid=542&view=trace>Memory leak detected [Ref = 1, Handle = 0x0B1730B0]: Object created by clEnqueueNDRangeKernel
</a></td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>216</td>	<td>208</td>	<td>2268</td>	<td>Best Practices</td>	<td><a href=#?tid=2268&seqid=208&view=trace>clEnqueueNDRangeKernel: Work group size is too small - [1,1,1]. Recommended Work group size is a multiple of 64.</a></td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>270</td>	<td>319</td>	<td>2268</td>	<td>Best Practices</td>	<td><a href=#?tid=2268&seqid=319&view=trace>clEnqueueNDRangeKernel: Global work size is too small - [111], resulting in low GPU utilization.</a></td>	</tr>
		<tr bgcolor = "#FFFFFF"><td>144</td>	<td>482</td>	<td>1932</td>	<td>Error</td>	<td><a href=#?tid=1932&seqid=482&view=trace>clEnqueueNDRangeKernel returns CL_INVALID_KERNEL_ARGS</a></td>	</tr>
	</table>
</p>
From these summary pages, it is possible to determine whether the application is bound by kernel execution or data transfer (Context Summary page).
 If the application is bound by kernel execution, you can determine which device is the bottleneck.  From the Kernel Summary page, you can find the
name of the kernel with the highest total execution time.  From the Top 10 Kernel Summary page, you can find the individual kernel instance with the
highest execution time.  If the kernel execution on a GPU device is the bottleneck, the GPU performance counters can then be used to investigate the
bottleneck inside the kernel.
</p>
<p>
If the application is bound by the data transfers, it is possible to determine the most expensive data transfer type (read, write, copy or map) in
the application from the Context Summary page.  You can then investigate whether you can minimize this type of data transfer by modifying the
algorithm if necessary.  With help from the Timeline View, you can investigate whether data transfers have been executed in the most efficient way,
i.e. concurrently with a kernel execution.
</p>
 </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Apr 16 10:53:42 2012 for AMDAPPProfilerHelp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
